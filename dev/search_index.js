var documenterSearchIndex = {"docs":
[{"location":"morton/#Morton-Encoding","page":"Morton Encoding","title":"Morton Encoding","text":"","category":"section"},{"location":"morton/#ImplicitBVH.MortonAlgorithm","page":"Morton Encoding","title":"ImplicitBVH.MortonAlgorithm","text":"abstract type MortonAlgorithm\n\nMorton encoding algorithms; a new alg needs to implement:\n\nmorton_encode!(bounding_volumes, alg, options)\neltype(alg) -> Type\n\nAt the moment, only the canonical DefaultMortonAlgorithm is exported; we are prototyping extended Morton encoding algorithms as well to ideally improve BVH quality and reduce the number of contact checks during traversal.\n\n\n\n\n\n","category":"type"},{"location":"morton/#ImplicitBVH.DefaultMortonAlgorithm","page":"Morton Encoding","title":"ImplicitBVH.DefaultMortonAlgorithm","text":"struct DefaultMortonAlgorithm{M<:Union{UInt16, UInt32, UInt64}, T} <: ImplicitBVH.MortonAlgorithm\n\nCanonical Morton encoding algorithm using bit interleaving.\n\nThe Morton code type is specified by the exemplar parameter; supported types are UInt16, UInt32 and UInt64.\n\nIf compute_extrema=false and mins / maxs are defined, they will not be computed from the distribution of bounding volumes; useful if you have a fixed simulation box, for example. You must ensure that no bounding volume centers will touch or be outside these bounds, otherwise logically incorrect results will be silently produced.\n\nExamples\n\nUse 32-bit Morton encoding:\n\nusing ImplicitBVH\noptions = BVHOptions(morton=DefaultMortonAlgorithm(UInt32))\n\n\n\n\n\n","category":"type"},{"location":"morton/#ImplicitBVH.morton_encode!","page":"Morton Encoding","title":"ImplicitBVH.morton_encode!","text":"morton_encode!(\n    bounding_volumes::AbstractVector{<:BoundingVolume},\n    options=BVHOptions(),\n)\n\nEncode each each bounding volume (given as BoundingVolume) into Morton codes following the algorithm set in options.alg; the Morton codes are updated inline in the morton field of each bounding volume.\n\n\n\n\n\n","category":"function"},{"location":"morton/#ImplicitBVH.morton_encode_single","page":"Morton Encoding","title":"ImplicitBVH.morton_encode_single","text":"morton_encode_single(centre, mins, maxs, U::MortonUnsignedType=UInt32)\n\nReturn Morton code for a single 3D position centre scaled uniformly between mins and maxs. Works transparently for SVector, Vector, etc. with eltype UInt16, UInt32 or UInt64.\n\n\n\n\n\n","category":"function"},{"location":"morton/#ImplicitBVH.morton_scaling","page":"Morton Encoding","title":"ImplicitBVH.morton_scaling","text":"morton_scaling(::Type{UInt16}) = 2^5\nmorton_scaling(::Type{UInt32}) = 2^10\nmorton_scaling(::Type{UInt64}) = 2^21\n\nExclusive maximum number possible to use for 3D Morton encoding for each type.\n\n\n\n\n\n","category":"function"},{"location":"morton/#ImplicitBVH.morton_split3","page":"Morton Encoding","title":"ImplicitBVH.morton_split3","text":"morton_split3(v::UInt16)\nmorton_split3(v::UInt32)\nmorton_split3(v::UInt64)\n\nShift a number's individual bits such that they have two zeros between them.\n\n\n\n\n\n","category":"function"},{"location":"morton/#ImplicitBVH.bounding_volumes_extrema","page":"Morton Encoding","title":"ImplicitBVH.bounding_volumes_extrema","text":"bounding_volumes_extrema(bounding_volumes)\n\nCompute exclusive lower and upper bounds in iterable of bounding volumes, e.g. Vector{BBox}.\n\n\n\n\n\n","category":"function"},{"location":"morton/#ImplicitBVH.relative_precision","page":"Morton Encoding","title":"ImplicitBVH.relative_precision","text":"relative_precision(::Type{Float16}) = 1e-2\nrelative_precision(::Type{Float32}) = 1e-5\nrelative_precision(::Type{Float64}) = 1e-14\n\nRelative precision value for floating-point types.\n\n\n\n\n\n","category":"function"},{"location":"bounding_volumes/#Bounding-Volumes","page":"Bounding Volumes","title":"Bounding Volumes","text":"","category":"section"},{"location":"bounding_volumes/#ImplicitBVH.BoundingVolume","page":"Bounding Volumes","title":"ImplicitBVH.BoundingVolume","text":"struct BoundingVolume{V, I, M}\n\nBounding volume wrapper, containing a bounding volume of type V, an index of type I, and a computed Morton code of type M.\n\nThe index will be the one reported in case of contact during traversal; it can be anything (user-defined) to identify the bounding volume later in e.g. a simulation.\n\nFields\n\nvolume::V: the bounding volume, e.g. BSphere or BBox.\nindex::I: the user-defined index associated with this bounding volume.\nmorton::M: the Morton code for this bounding volume computed during BVH construction.\n\n\n\n\n\n","category":"type"},{"location":"bounding_volumes/#ImplicitBVH.BBox","page":"Bounding Volumes","title":"ImplicitBVH.BBox","text":"struct BBox{T}\n\nAxis-aligned bounding box, optimised for computing bounding volumes for triangles and merging into larger bounding volumes.\n\nCan also be constructed from two spheres to e.g. allow merging BSphere leaves into BBox nodes.\n\nMethods\n\n# Convenience constructors\nBBox(lo::NTuple{3, T}, up::NTuple{3, T}) where T\nBBox{T}(lo::AbstractVector, up::AbstractVector) where T\nBBox(lo::AbstractVector, up::AbstractVector)\n\n# Construct from triangle vertices\nBBox{T}(p1, p2, p3) where T\nBBox(p1, p2, p3)\nBBox{T}(vertices::AbstractMatrix) where T\nBBox(vertices::AbstractMatrix)\nBBox{T}(triangle) where T\nBBox(triangle)\n\n# Merging bounding boxes\nBBox{T}(a::BBox, b::BBox) where T\nBBox(a::BBox{T}, b::BBox{T}) where T\nBase.:+(a::BBox, b::BBox)\n\n# Merging bounding spheres\nBBox{T}(a::BSphere{T}) where T\nBBox(a::BSphere{T}) where T\nBBox{T}(a::BSphere{T}, b::BSphere{T}) where T\nBBox(a::BSphere{T}, b::BSphere{T}) where T\n\n\n\n\n\n","category":"type"},{"location":"bounding_volumes/#ImplicitBVH.BSphere","page":"Bounding Volumes","title":"ImplicitBVH.BSphere","text":"struct BSphere{T}\n\nBounding sphere, optimised for computing bounding volumes for triangles and merging into larger bounding volumes.\n\nMethods\n\n# Convenience constructors\nBSphere(x::NTuple{3, T}, r)\nBSphere{T}(x::AbstractVector, r) where T\nBSphere(x::AbstractVector, r)\n\n# Construct from triangle vertices\nBSphere{T}(p1, p2, p3) where T\nBSphere(p1, p2, p3)\nBSphere{T}(vertices::AbstractMatrix) where T\nBSphere(vertices::AbstractMatrix)\nBSphere{T}(triangle) where T\nBSphere(triangle)\n\n# Merging bounding volumes\nBSphere{T}(a::BSphere, b::BSphere) where T\nBSphere(a::BSphere{T}, b::BSphere{T}) where T\nBase.:+(a::BSphere, b::BSphere)\n\n\n\n\n\n","category":"type"},{"location":"bounding_volumes/#Query-Functions","page":"Bounding Volumes","title":"Query Functions","text":"","category":"section"},{"location":"bounding_volumes/#ImplicitBVH.iscontact","page":"Bounding Volumes","title":"ImplicitBVH.iscontact","text":"iscontact(a::BSphere, b::BSphere)\niscontact(a::BBox, b::BBox)\niscontact(a::BSphere, b::BBox)\niscontact(a::BBox, b::BSphere)\n\nCheck if two bounding volumes are touching or inter-penetrating.\n\n\n\n\n\n","category":"function"},{"location":"bounding_volumes/#ImplicitBVH.isintersection","page":"Bounding Volumes","title":"ImplicitBVH.isintersection","text":"isintersection(\n    b::BBox{T},\n    p::Union{AbstractVector{T}, NTuple{3, T}},\n    d::Union{AbstractVector{T}, NTuple{3, T}},\n) where T\n\nisintersection(\n    s::BSphere{T},\n    p::Union{AbstractVector{T}, NTuple{3, T}},\n    d::Union{AbstractVector{T}, NTuple{3, T}},\n) where T\n\nCheck if a forward ray, defined by a point p and a direction d intersects a bounding volume; p and d can be any iterables with 3 numbers (e.g. Vector{Float64}).\n\n\n\n\n\n","category":"function"},{"location":"bounding_volumes/#ImplicitBVH.center","page":"Bounding Volumes","title":"ImplicitBVH.center","text":"center(b::BSphere)\ncenter(b::BBox{T}) where T\n\nGet the coordinates of a bounding volume's centre, as a NTuple{3, T}.\n\n\n\n\n\n","category":"function"},{"location":"implicit_tree/#Implicit-Binary-Tree","page":"Implicit Binary Tree","title":"Implicit Binary Tree","text":"","category":"section"},{"location":"implicit_tree/#ImplicitBVH.ImplicitTree","page":"Implicit Binary Tree","title":"ImplicitBVH.ImplicitTree","text":"struct ImplicitTree{T<:Integer}\n\nImplicit binary tree for num_leaves elements, where nodes are labelled according to a breadth-first search.\n\nMethods\n\nImplicitTree(num_leaves::Integer)\nImplicitTree{T}(num_leaves::Integer)\n\nFields\n\nlevels::Integer: Number of levels in the tree.\nreal_leaves::Integer: Number of real leaves - i.e. the elements from which the tree was constructed.\nreal_nodes::Integer: Total number of real nodes in tree.\nvirtual_leaves::Integer: Number of virtual leaves needed at the bottom level to have a perfect binary tree.\nvirtual_nodes::Integer: Total number of virtual nodes in tree needed for a complete binary tree.\n\nExamples\n\njulia> using ImplicitBVH\n\n# Given 5 geometric elements (e.g. bounding boxes) we construct the following implicit tree\n# having the 5 real leaves at implicit indices 8-12 plus 3 virtual leaves.\n#         Nodes & Leaves                Tree Level\n#               1                       1\n#       2               3               2\n#   4       5       6        7v         3\n# 8   9   10 11   12 13v  14v  15v      4\njulia> tree = ImplicitTree(5)\nImplicitTree{Int64}\n  levels: Int64 4\n  real_leaves: Int64 5\n  real_nodes: Int64 11\n  virtual_leaves: Int64 3\n  virtual_nodes: Int64 4\n\n# We can keep all tree nodes in a contiguous vector with no extra padding for the virtual\n# nodes by computing the real memory index of real nodes; e.g. real memory index of node 8\n# skips node 7 which is virtual:\njulia> memory_index(tree, 8)\n7\n\n# We can get the range of indices of real nodes on a given level\njulia> level_indices(tree, 3)\n(4, 6)\n\n# And we can check if a node at a given implicit index is virtual\njulia> isvirtual(tree, 6)\nfalse\n\njulia> isvirtual(tree, 7)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"implicit_tree/#ImplicitBVH.memory_index","page":"Implicit Binary Tree","title":"ImplicitBVH.memory_index","text":"memory_index(tree::ImplicitTree, implicit_index::Integer)\n\nReturn actual memory index for a node at implicit index i in a perfect BFS-labelled tree.\n\n\n\n\n\n","category":"function"},{"location":"implicit_tree/#ImplicitBVH.level_indices","page":"Implicit Binary Tree","title":"ImplicitBVH.level_indices","text":"level_indices(tree::ImplicitTree, level::Integer)\n\nReturn range Tuple{Int64, Int64} of memory indices of elements at level.\n\n\n\n\n\n","category":"function"},{"location":"implicit_tree/#ImplicitBVH.isvirtual","page":"Implicit Binary Tree","title":"ImplicitBVH.isvirtual","text":"isvirtual(tree::ImplicitTree, implicit_index::Integer)\n\nCheck if given implicit_index corresponds to a virtual node.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/#ImplicitBVH.BVHOptions","page":"Utilities","title":"ImplicitBVH.BVHOptions","text":"struct BVHOptions{I<:Integer, M}\n\nOptions for building and traversing bounding volume hierarchies, including parallel strategy settings.\n\nAn exemplar of an index (e.g. Int32(0)) is used to deduce the types of indices used in the BVH building (ImplicitTree, order) and traversal (IndexPair).\n\nMethods\n\nBVHOptions(;\n\n    # Example index from which to deduce type\n    index::Union{I, Type{I}}            = Int32(0),\n\n    # Morton encoding algorithm\n    morton::M                           = DefaultMortonAlgorithm(UInt32(0)),\n\n    # CPU threading\n    num_threads::Int                    = Threads.nthreads(),\n    min_mortons_per_thread::Int         = 100,\n    min_sorts_per_thread::Int           = 100,\n    min_boundings_per_thread::Int       = 100,\n    min_traversals_per_thread::Int      = 100,\n\n    # GPU scheduling\n    block_size::Int                     = 256,\n) where {I <: Integer, M}\n\nFields\n\nindex_exemplar::Integer\nmorton::Any\nnum_threads::Int64\nmin_mortons_per_thread::Int64\nmin_sorts_per_thread::Int64\nmin_boundings_per_thread::Int64\nmin_traversals_per_thread::Int64\nblock_size::Int64\n\n\n\n\n\n","category":"type"},{"location":"utilities/#ImplicitBVH.get_index_type","page":"Utilities","title":"ImplicitBVH.get_index_type","text":"Get index type from options or derived data types.\n\nMethods\n\nget_index_type(::ImplicitTree{I}) where I\nget_index_type(bvh::BVH)\nget_index_type(options::BVHOptions)\n\n\n\n\n\n","category":"function"},{"location":"#ImplicitBVH.jl-Documentation","page":"ImplicitBVH.jl Documentation","title":"ImplicitBVH.jl Documentation","text":"","category":"section"},{"location":"#BVH-Construction-and-Traversal","page":"ImplicitBVH.jl Documentation","title":"BVH Construction & Traversal","text":"","category":"section"},{"location":"#ImplicitBVH.BVH","page":"ImplicitBVH.jl Documentation","title":"ImplicitBVH.BVH","text":"struct BVH{I<:Integer, VS<:(AbstractVector), VN<:(AbstractVector), VL<:(AbstractVector)}\n\nImplicit bounding volume hierarchy constructed from an iterable of some geometric primitives' (e.g. triangles in a mesh) bounding volumes forming the ImplicitTree leaves. The leaves and merged nodes above them can have different types - e.g. BSphere{Float64} for leaves merged into larger BBox{Float64}.\n\nThe initial geometric primitives are sorted according to their Morton-encoded coordinates; the encoding algorithm is specified within the BVHOptions.\n\nFinally, the tree can be incompletely-built up to a given built_level and later start contact detection downwards from this level, e.g.:\n\nImplicit tree from 5 bounding volumes - i.e. the real leaves\n\nTree Level          Nodes & Leaves               Build Up    Traverse Down\n    1                     1                         É…              |\n    2             2               3                 |              |\n    3         4       5       6        7v           |              |\n    4       8   9   10 11   12 13v  14v  15v        |              V\n            -------Real------- ---Virtual---\n\nMethods\n\n# Normal constructor which builds BVH\nBVH(\n    bounding_volumes::AbstractVector{L},\n    node_type::Type{N}=BBox{Float32};\n    built_level::Union{Integer, AbstractFloat}=1,\n    cache::Union{Nothing, BVH}=nothing,\n    options=BVHOptions(),\n) where {L, N}\n\nFields\n\nbuilt_level::Int - level up to which the BVH tree has been built\ntree::ImplicitTree{I <: Integer}\nskips::VS <: AbstractVector - vector of skips (number of indices to jump in memory, per level)\nnodes::VN <: AbstractVector - vector of bounding volumes for the internal nodes above the leaves\nleaves::VL <: AbstractVector - vector of sorted BoundingVolume for the leaves\n\nExamples\n\nSimple usage with bounding spheres as leaves (defaults include BBox{Float32} nodes, UInt32 Morton codes, and Int32 indices):\n\nusing ImplicitBVH\nusing ImplicitBVH: BSphere\n\n# Generate some simple bounding spheres\nbounding_spheres = [\n    BSphere([0., 0., 0.], 0.5),\n    BSphere([0., 0., 1.], 0.6),\n    BSphere([0., 0., 2.], 0.5),\n    BSphere([0., 0., 3.], 0.4),\n    BSphere([0., 0., 4.], 0.6),\n]\n\n# Build BVH\nbvh = BVH(bounding_spheres)\n\n# Traverse BVH for contact detection\ntraversal = traverse(bvh)\n@show traversal.contacts;\n;\n\n# output\ntraversal.contacts = Tuple{Int32, Int32}[(1, 2), (2, 3), (4, 5)]\n\nUsing Float32 bounding spheres for leaves, Float32 bounding boxes for nodes above, UInt64 Morton codes and Int64 indices:\n\nusing ImplicitBVH\nusing ImplicitBVH: BBox, BSphere\n\n# Generate some simple bounding spheres\nbounding_spheres = [\n    BSphere{Float32}([0., 0., 0.], 0.5),\n    BSphere{Float32}([0., 0., 1.], 0.6),\n    BSphere{Float32}([0., 0., 2.], 0.5),\n    BSphere{Float32}([0., 0., 3.], 0.4),\n    BSphere{Float32}([0., 0., 4.], 0.6),\n]\n\n# Build BVH\noptions = BVHOptions(index=Int64, morton=DefaultMortonAlgorithm(UInt64))\nbvh = BVH(bounding_spheres, BBox{Float32}, options=options)\n\n# Traverse BVH for contact detection\ntraversal = traverse(bvh)\n@show traversal.contacts;\n;\n\n# output\ntraversal.contacts = [(1, 2), (2, 3), (4, 5)]\n\nBuild BVH up to level 2 and start traversing down from level 3, reusing the previous traversal cache:\n\nbvh = BVH(bounding_spheres, BBox{Float32}, built_level=2)\ntraversal = traverse(bvh, start_level=3, cache=traversal)\n\nReuse previous BVH memory for a new BVH (i.e. the nodes, but not the leaves, which are modified in-place):\n\nbvh = BVH(bounding_spheres, BBox{Float32}, cache=bvh)\n\nMove previous BVH leaves / bounding volumes to new locations then rebuild BVH in-place:\n\nfor ibv in eachindex(bvh.leaves)\n    bvh.leaves[ibv] = BoundingVolume(\n        bvh.leaves[ibv].volume,             # Update if needed\n        bvh.leaves[ibv].index,              # Your simulation indices, reported in contacts\n        bvh.leaves[ibv].morton,             # Will be recomputed when rebuilding\n    )\nend\nbvh = BVH(bvh.leaves, BBox{Float32}, cache=bvh)\n\nManually wrap bounding volumes into BoundingVolume structs before building BVH:\n\nusing ImplicitBVH\nusing ImplicitBVH: BoundingVolume, BSphere, BBox\n\n# Generate some simple bounding spheres with explicit simulation indices (will be reported in\n# contacts; allows different indexing strategies) and dummy morton codes (will be computed when\n# building the BVH)\nbounding_spheres = [\n    BoundingVolume(BSphere{Float32}([0., 0., 1.], 0.6), Int32(1), UInt32(0)),\n    BoundingVolume(BSphere{Float32}([0., 0., 2.], 0.5), Int32(2), UInt32(0)),\n    BoundingVolume(BSphere{Float32}([0., 0., 0.], 0.5), Int32(3), UInt32(0)),\n    BoundingVolume(BSphere{Float32}([0., 0., 3.], 0.4), Int32(4), UInt32(0)),\n    BoundingVolume(BSphere{Float32}([0., 0., 4.], 0.6), Int32(5), UInt32(0)),\n]\n\n# Build BVH\nbvh = BVH(bounding_spheres, BBox{Float32})\n\n# The bounding_spheres was modified in-place, without extra allocations\n@show bounding_spheres[1];\n;\n\n# output\nbounding_spheres[1] = ImplicitBVH.BoundingVolume{ImplicitBVH.BSphere{Float32}, Int32, UInt32}(ImplicitBVH.BSphere{Float32}((0.0f0, 0.0f0, 0.0f0), 0.5f0), 3, 0x06186186)\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitBVH.traverse","page":"ImplicitBVH.jl Documentation","title":"ImplicitBVH.traverse","text":"traverse(\n    bvh::BVH, alg::TraversalAlgorithm=LVTTraversal();\n    start_level::Int=default_start_level(bvh, alg),\n    narrow=(bv1, bv2) -> true,\n    cache::Union{Nothing, BVHTraversal}=nothing,\n    options=BVHOptions(),\n)::BVHTraversal\n\ntraverse(\n    bvh1::BVH, bvh2::BVH, alg::TraversalAlgorithm=LVTTraversal();\n    start_level1::Int=default_start_level(bvh1, alg),\n    start_level2::Int=default_start_level(bvh2, alg),\n    narrow=(bv1, bv2) -> true,\n    cache::Union{Nothing, BVHTraversal}=nothing,\n    options=BVHOptions(),\n)::BVHTraversal\n\nTraverse bvh downwards from start_level, returning all contacting bounding volume leaves, using the traversal algorithm alg (TraversalAlgorithm). The returned BVHTraversal also contains two buffers that can be reused on future traversals as cache to avoid reallocations.\n\nThe optional narrow function can be used to perform a custom narrow-phase test between two bounding volumes bv1 and bv2 before registering a contact. By default, all bounding volume pairs reaching the narrow-phase are considered contacting.\n\nExamples\n\nusing ImplicitBVH\nusing ImplicitBVH: BBox, BSphere\n\n# Generate some simple bounding spheres\nbounding_spheres = [\n    BSphere{Float32}([0., 0., 0.], 0.5),\n    BSphere{Float32}([0., 0., 1.], 0.6),\n    BSphere{Float32}([0., 0., 2.], 0.5),\n    BSphere{Float32}([0., 0., 3.], 0.4),\n    BSphere{Float32}([0., 0., 4.], 0.6),\n]\n\n# Build BVH\nbvh = BVH(bounding_spheres, BBox{Float32})\n\n# Traverse BVH for contact detection\ntraversal = traverse(bvh)\n\n# Reuse traversal buffers for future contact detection - possibly with different BVHs\ntraversal = traverse(bvh, cache=traversal)\n@show traversal.contacts;\n;\n\n# output\ntraversal.contacts = Tuple{Int32, Int32}[(1, 2), (2, 3), (4, 5)]\n\nTraverse bvh1 and bvh2 downwards from start_level1 and start_level2, returning all contacting bounding volume leaves:\n\nusing ImplicitBVH\nusing ImplicitBVH: BBox, BSphere\n\n# Generate some simple bounding spheres\nbounding_spheres1 = [\n    BSphere{Float32}([0., 0., 0.], 0.5),\n    BSphere{Float32}([0., 0., 3.], 0.4),\n]\n\nbounding_spheres2 = [\n    BSphere{Float32}([0., 0., 1.], 0.6),\n    BSphere{Float32}([0., 0., 2.], 0.5),\n    BSphere{Float32}([0., 0., 4.], 0.6),\n]\n\n# Build BVHs\nbvh1 = BVH(bounding_spheres1, BBox{Float32})\nbvh2 = BVH(bounding_spheres2, BBox{Float32})\n\n# Traverse BVH for contact detection\ntraversal = traverse(bvh1, bvh2, start_level1=2, start_level2=3)\n\n# Reuse traversal buffers for future contact detection - possibly with different BVHs\ntraversal = traverse(bvh1, bvh2, cache=traversal)\n@show traversal.contacts;\n;\n\n# output\ntraversal.contacts = Tuple{Int32, Int32}[(1, 1), (2, 3)]\n\n\n\n\n\n","category":"function"},{"location":"#ImplicitBVH.traverse_rays","page":"ImplicitBVH.jl Documentation","title":"ImplicitBVH.traverse_rays","text":"traverse_rays(\n    bvh::BVH,\n    points::AbstractMatrix, directions::AbstractMatrix,\n    alg::TraversalAlgorithm=LVTTraversal();\n    start_level::Int=1,\n    narrow=(bv, p, d) -> true,\n    cache::Union{Nothing, BVHTraversal}=nothing,\n    options=BVHOptions(),\n)::BVHTraversal\n\nCompute the intersections between a set of N rays defined by points (shape (3, N)) and directions (shape, (3, N)), and some bounding volumes inside a bvh. Traverse bvh downwards from start_level, returning all contacting bounding volume leaves, using the traversal algorithm alg (TraversalAlgorithm). The returned BVHTraversal also contains two buffers that can be reused on future traversals as cache to avoid reallocations.\n\nOnly forward rays are counted - i.e. the direction matters.\n\nThe returned BVHTraversal .contacts field will contain the index pairs (iboundingvolume, iray) following the indices in bvh.leaves and axes(points, 2).\n\nThe optional narrow function can be used to perform a custom narrow-phase test between a bounding volume bv, a ray point p and direction d before registering a contact. By default, all bounding volume and ray pairs reaching the narrow-phase are considered contacting.\n\nExamples\n\nusing ImplicitBVH\nusing ImplicitBVH: BBox, BSphere\n\n# Generate some simple bounding spheres\nbounding_spheres = [\n    BSphere{Float32}([0., 0., 0.], 0.5),\n    BSphere{Float32}([0., 0., 1.], 0.6),\n    BSphere{Float32}([0., 0., 2.], 0.5),\n    BSphere{Float32}([0., 0., 3.], 0.4),\n    BSphere{Float32}([0., 0., 4.], 0.6),\n]\n\n# Generate two rays, each defined by a point source and direction\npoints = [\n    0.  0 \n    0.  0\n    -1 -1\n]\n\n# One ray passes through all bounding volumes, the other goes downwards and does not\ndirections = [\n    0.  0\n    0.  0\n    1.  -1\n]\n\n# Build BVH\nbvh = BVH(bounding_spheres)\n\n# Traverse BVH for contact detection\ntraversal = traverse_rays(bvh, points, directions)\n\n# Reuse traversal buffers for future contact detection - possibly with different BVHs\ntraversal = traverse_rays(bvh, points, directions, cache=traversal)\n@show traversal.contacts;\n;\n\n# output\ntraversal.contacts = Tuple{Int32, Int32}[(1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n\n\n\n\n\n","category":"function"},{"location":"#ImplicitBVH.BVHTraversal","page":"ImplicitBVH.jl Documentation","title":"ImplicitBVH.BVHTraversal","text":"struct BVHTraversal{C1<:(AbstractVector), C2<:(AbstractVector)}\n\nCollected BVH traversal contacts vector, some stats, plus the two buffers cache1 and cache2 which can be reused for future traversals to minimise memory allocations.\n\nFields\n\nstart_level1::Int: the level at which the single/pair-tree traversal started for the first BVH.\nstart_level2::Int: the level at which the pair-tree traversal started for the second BVH.\nnum_checks::Int: the number of contact checks performed during traversal, not always computed.\nnum_contacts::Int: the number of contacts found.\ncontacts::view(cache_contacts, 1:num_contacts): the contacting pairs found, as a view into cache1.\ncache1::C1{IndexPair} <: AbstractVector: cache of all contacts found (may have greater size; use num_contacts).\ncache2::C2{IndexPair} <: AbstractVector: second cache used, depending on the traversal algorithm.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitBVH.TraversalAlgorithm","page":"ImplicitBVH.jl Documentation","title":"ImplicitBVH.TraversalAlgorithm","text":"abstract type TraversalAlgorithm end\nstruct BFSTraversal <: TraversalAlgorithm end\nstruct LVTTraversal <: TraversalAlgorithm end\n\nThe algorithm used to traverse one / two BVHs for contact detection and ray-tracing.\n\nIn general, use LVTTraversal (the default) unless you use few CPU threads and memory usage is not a bottleneck.\n\nBFSTraversal\n\nSimultaneous breadth-first search traversal - nodes are paired level-by-level:\n\nTheoretical minimum number of contact checks.\nMuch higher memory usage (spiking at around 10-20x the final number of contacts found).\nFaster on CPUs with few threads, but slightly worse scalability.\nMore kernel launches (thread launches or enqueues - one per level).\n\nLVTTraversal\n\nLeaf-vs-tree traversal - independent traversal of leaves in one BVH against the entire other BVH:\n\nMore contact checks (around 10x more than BFSTraversal).\nMuch lower memory usage (only the final number of contacts found, plus 4/8 bytes per CPU/GPU thread).\nExcellent cache locality - can yield ~17 processor cycles per contact check.\nMuch faster on GPUs (about 4x faster than BFSTraversal), with better scalability due to improved memory and work divergence.\nFewer kernel launches (thread launches or enqueues = 2 passes + accumulate).\nAbout 2-3x slower on CPUs when single-threaded, but ideal scalability with threads.\n\n\n\n\n\n","category":"type"},{"location":"#ImplicitBVH.default_start_level","page":"ImplicitBVH.jl Documentation","title":"ImplicitBVH.default_start_level","text":"default_start_level(bvh::BVH, alg::TraversalAlgorithm)::Int\n\nCompute the default start level for BVH traversal given the BVH and the traversal algorithm.\n\n\n\n\n\n","category":"function"},{"location":"#ImplicitBVH.IndexPair","page":"ImplicitBVH.jl Documentation","title":"ImplicitBVH.IndexPair","text":"const IndexPair{I} = Tuple{I, I}\n\nAlias for a tuple of two indices representing e.g. a contacting pair.\n\n\n\n\n\n","category":"type"},{"location":"#Index","page":"ImplicitBVH.jl Documentation","title":"Index","text":"","category":"section"},{"location":"","page":"ImplicitBVH.jl Documentation","title":"ImplicitBVH.jl Documentation","text":"","category":"page"}]
}
